---
layout: post
title: "Python"
description: ""
category: "language"
tags: ['Python']
tagline: by David
---
{% include JB/setup %}

Python的一些总结

<!--more-->

Python这个语言有很多实现版本，使用C，Java，.Net还有Python自身实现的版本：
    
    Jython          Java
    IronPython      .Net
    PyPy            Python
    Python          C  

Python的第三方module管理主要由两个工具：[easy_install](https://pypi.python.org/pypi/setuptools) 和 [pip](https://pypi.python.org/pypi/pip)

Python的开发工具有很多，主要使用`PyDev`和`Sublime`

Python的内置module `__builtins__`,常用的内置方法有：

     __import__
     reload
     dir
     help
     type
     vars/locals/globals
     isinstance
     issubclass
     callable
     getatter
     ....

表达式推导(List comprehensions)
     
     >>>[i for i in range(100) if i%2 == 0]
     
     >>>seq = ["one", "two", "three"]
     >>>for i ,e in enumerate(seq):
     ...   seq[i] = '%d:%s' %(i,seq[i])
     >>>print seq
      
     >>>dict([(line.split(":")[0], line.split(":")[1]) for line in seq])
     
 Iterator和生成器([Generator](https://docs.python.org/2/tutorial/classes.html#iterators))
     
 >Iterator的实现方式: 使用内置方法`iter` 或者 实现`next`和`__iter__` 方法
 
     it=iter("abcded")
     
     class MyIterator(object):
        def __init__(self, step):
            self.step = step
    
        def next(self):
            if self.step == 0:
                 raise StopIteration
            self.step -= 1
            return self.step
    
        def __iter__(self):
            return self

如果迭代结束了，再调用`next()`方法, Python会抛出`StopIteration`的异常。

>使用关键字`yield`可以生成生成器
    
    def fibonacci():
        a, b = 0, 1
        while True:
            yield b
            a, b = b, a+b
    
    fib = fibonacci()
    fib.next()
    
    [fib.next for i in range(10)]

> 保持代码简单，而不是数据

Python引入的与生成器相关的最后一个特性是提供了与next方法调用的代码进行交互的功能。yield将变成一个表达式，而值可以通过`send`,`throw`和`close`来传递

    def psychologist():
        print "Please tell me your problems"
        while True:
            answer = (yield)
            if answer is not None:
                if answer.endswith('?'):
                    print "Don't ask yourself too much questions"
                elif 'good' in answer:
                    print "A that's good, go on"
                elif 'bad' in answer:
                    print "Don't be so negative"
                    
    def my_generator():
        try:
            yield 'something'
        except ValueError:
            yield 'dealing with the exception'
        finally:
            print "OK let's clean"
     
装饰器

>函数也是对象，也可以被赋值给变量，所以通过变量也可以调用该函数

    def log(func):
        def wrapper(*args, **kw):
            print 'call %s():' % func.__name__
            return func(*args, **kw)
        return wrapper  
        
    @log
    def now():
        print time.time()
        
    >>> now()
    
把`@log`放到`now()`函数的上面，相当于执行了now=log(now), 这样称log()是一个decorator，但是这里存在一个问题，由于now函数被包装了，所以它的`__name__`也被修改成`wrapper`,不是`now`,如何解决找个问题呢？可以使用Python内置的functools.wraps
    
    import functools
    def log(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print 'call %s():' % func.__name__
            return func(*args, **kw)
        return wrapper  
        
高阶的decorator

    def log_s(text):
        def decorator(func):
            def wrapper(*args, **kw):
                print "%s %s():" % (text, func.__name__)
                print func.__name__
                return func(*args, **kw)
            return wrapper
        return decorator
    
    @log_s("hello world")
    def now():
        print time.time()
        
相当于执行了now=log_s('hello world')(now)




        
   
    

    


    
